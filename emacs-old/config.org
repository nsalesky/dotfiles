#+title: My Emacs Configuration
#+author: Nick Salesky
#+PROPERTY: header-args:emacs-lisp :tangle init.el
#+STARTUP: overview

* About
This is my personal Emacs config that I've built with the "help" :) of many other open-source configs, blog posts, articles, etc. When possible, I try to attribute specific sections to the original source for both my benefit and anyone else's. I started using Emacs with the help of [[https://github.com/doomemacs/doomemacs][Doom Emacs]], so many of my keybindings and other settings are inspired by that.

One important thing is that I haven't really done any effort to shorten the Emacs loading time, so this config takes a while to start up (about 8 seconds or so on my machine). I usually just keep Emacs open or use a daemon so this isn't an issue for me, but maybe something for me to look into in the future!

Some specific configs I looked at include:

- [[https://github.com/dakra/dmacs][Dmacs]] (the structure of this config file is heavily inspired by this!)
- [[https://www.youtube.com/watch?v=SCPoF1PTZpI&t=896s][System Crafters]]

* Installation

Installation should be fairly straightforward. The first time Emacs runs this config, it should hopefully install all the necessary packages automatically. If it doesn't prompt you, you'll need to run ~M-x all-the-icons-install-fonts~.

* Emacs Initialization 

Enable native compilation for all Elisp code
#+BEGIN_SRC emacs-lisp
(setq native-comp-deferred-compilation t)
#+END_SRC

Disable certain byte compiler warnings to cut down on the noise for (usually unnecessary) errors.

#+BEGIN_SRC emacs-lisp
(setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local)
      native-comp-async-report-warnings-errors nil)
#+END_SRC 

Increase the garbage collection threshold and process data chunking for performance.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 100000000
      read-process-output-max (* 1024 1024))
#+END_SRC 

** Set some basic UI settings early

Disable UI elements
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode 1)
(scroll-bar-mode -1)
(tooltip-mode -1)
(set-fringe-mode 10)
#+END_SRC

Disable the startup message
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
#+END_SRC 

Use short answers for prompts
#+BEGIN_SRC emacs-lisp
(setq use-short-answers t)
#+END_SRC 

Don't confirm nonexistent files or buffers
#+BEGIN_SRC emacs-lisp
(setq confirm-nonexistent-file-or-buffer nil)
#+END_SRC 

** custom.el
Create a ~custom.el~ file to store customization info instead of init.el, since this is a literal config.

#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
#+END_SRC

** set up the load path
Add custom lisp files to the =load-path=
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))
#+END_SRC

* Package System Setup
I'm using =package.el= with =use-package= to install and configure packages

#+BEGIN_SRC emacs-lisp
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(package-initialize)
#+END_SRC

Set up =use-package=
#+BEGIN_SRC emacs-lisp
(require 'use-package-ensure)
(setq use-package-always-pin  "melpa"
      use-package-always-ensure t
      use-package-compute-statistics t)
#+END_SRC


Set up environment variables
#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :config
  (exec-path-from-shell-initialize))
#+END_SRC 

* Personal Information
Set up the basic user information variables.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Nick Salesky"
      user-mail-address "nicksalesky@gmail.com")
#+END_SRC 

* Keybindings and Basic Feature Configuration
Here's where I configure some basic Emacs features with keybindings.

** Set up modifiers for Mac OS X
#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (setq mac-option-key-is-meta t
        mac-command-key-is-meta t
        mac-command-modifier 'meta
        mac-option-modifier 'meta))
#+END_SRC

** Enable all disabled keybindings
#+BEGIN_SRC emacs-lisp
(setq disabled-command-function nil)
#+END_SRC

** Electric-pair-mode
Disable ~electric-pair-mode~ for a select subset of modes. 

#+BEGIN_SRC emacs-lisp
(electric-pair-mode 1)
(setq electric-pair-inhibit-predicate
      (lambda (char)
        (member major-mode '(org-mode))))
#+END_SRC

** Disable ESC ESC ESC

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "ESC ESC"))
#+END_SRC

** Replace selected text
Enable =delete-selection-mode= so that if there is a marked region, typing in text replaces it

#+BEGIN_SRC emacs-lisp
(delete-selection-mode 1)
#+END_SRC

** Indentation: spaces, not tabs!
Set up the indentation behavior. I took this basic configuration from [[https://dougie.io/emacs/indentation/]]

#+begin_src emacs-lisp

;; Set the default tab settings
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)
(setq-default c-basic-offset 4)
(setq-default python-indent-offset 4)

;; Make the backspace properly erase the whole tab instead of removing
;; 1 space at a time
(setq backward-delete-char-untabify-method 'hungry)

#+end_src

** Files
Keybindings for working with files.

#+BEGIN_SRC emacs-lisp

  ;; Keep track of recently-opened files
  (use-package recentf
    :ensure nil
    :config
    (recentf-mode 1)
    :custom
    (recentf-max-menu-items 5000)
    (recentf-max-saved-items 10000)
    :bind
    ("C-x C-r" . consult-recent-file))
    ;; :general
    ;; (ns/leader-def "fr" 'consult-recent-file))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (ns/leader-def
    "." 'find-file
    "f" '(:ignore t :which-key "files")
    "fs" 'find-file)
#+END_SRC

** Buffers
#+BEGIN_SRC emacs-lisp :tangle no
(ns/leader-def
  "," '(consult-buffer :which-key "select buffer")
  "b" '(:ignore t :which-key "buffers")
  "bb" '(consult-buffer :which-key "select buffer"))
#+END_SRC

** Windows
Keybindings for operating windows.

#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :bind ("M-o" . ace-window))
#+END_SRC

** Text manipulation

#+BEGIN_SRC emacs-lisp :tangle no
(ns/leader-def
  "/" '(comment-line :which-key "Toggle comment"))
#+END_SRC

** Eval
#+BEGIN_SRC emacs-lisp :tangle no
(ns/leader-def
  "e" '(:ignore t :which-key "eval")
  "el" '(eval-last-sexp :which-key "eval last sexpr")
  "ed" '(eval-defun :which-key "eval defun")
  "e:" '(eval-expression :which-key "eval expression"))
#+END_SRC

** Dumb-jump

#+BEGIN_SRC emacs-lisp
(use-package hydra)

(use-package dumb-jump
  :config
  (defhydra dumb-jump-hydra (:color blue :columns 3)
    "Dumb Jump"
    ("j" dumb-jump-go "Go")
    ("o" dumb-jump-go-other-window "Other window")
    ("e" dumb-jump-go-prefer-external "Go external")
    ("x" dumb-jump-go-prefer-external-other-window "Go external other window")
    ("i" dumb-jump-go-prompt "Prompt")
    ("l" dumb-jump-quick-look "Quick look")
    ("b" dumb-jump-back "Back"))
  (keymap-global-set "M-g j" 'dumb-jump-hydra/body))
#+END_SRC

** evil-textobj-tree-sitter
#+BEGIN_SRC emacs-lisp :tangle no
(use-package evil-textobj-tree-sitter
  :config
  ; functions
  (define-key evil-outer-text-objects-map "f"
              (evil-textobj-tree-sitter-get-textobj "function.outer"))
  (define-key evil-inner-text-objects-map "f"
              (evil-textobj-tree-sitter-get-textobj "function.inner"))
  (define-key evil-normal-state-map
              (kbd "]f")
              (lambda ()
                (interactive)
                (evil-textobj-tree-sitter-goto-textobj "function.outer")))
  (define-key evil-normal-state-map
              (kbd "[f")
              (lambda ()
                (interactive)
                (evil-textobj-tree-sitter-goto-textobj "function.outer" t))))
#+END_SRC

* Configure builtin/core Emacs packages
** Misc
#+BEGIN_SRC emacs-lisp
(use-package emacs
  :ensure nil
  :custom
  (scroll-margin 5)
  (ring-bell-function 'ignore)
  :config
  (pixel-scroll-mode 1)
  (global-visual-line-mode 1))
#+END_SRC

** Saveplace: Remember your location in a file
#+BEGIN_SRC emacs-lisp

(use-package saveplace
  :ensure nil
  :unless noninteractive
  :config
  (setq save-place-limit 1000)
  (save-place-mode))

#+END_SRC 

** Savehist: Keep track of minibuffer history
#+BEGIN_SRC emacs-lisp

(use-package savehist
  :ensure nil
  :unless noninteractive
  :defer 1
  :config
  (setq savehist-additional-variables '(compile-command kill-ring regexp-search-ring))
  (savehist-mode 1))

#+END_SRC 

** +Global-auto-revert-mode+
Auto-revert all buffers by default

#+BEGIN_SRC emacs-lisp :tangle no
(global-auto-revert-mode 1)
#+END_SRC

** Backup and auto-save files
Put all backup and auto-save files in subfolders of the Emacs directory instead of littering the filesystem with them, including for Tramp sessions.
I got the basic code for this from [[https://emacs.stackexchange.com/questions/33/put-all-backups-into-one-backup-folder]]

#+BEGIN_SRC emacs-lisp
(let ((backup-dir (concat user-emacs-directory "backups"))
      (auto-saves-dir (concat user-emacs-directory "auto-saves")))
  (dolist (dir (list backup-dir auto-saves-dir))
    (when (not (file-directory-p dir))
      (make-directory dir t)))
  (setq backup-directory-alist `(("." . ,backup-dir))
        auto-save-file-name-transforms `((".*" ,auto-saves-dir t))
        tramp-backup-directory-alist `((".*" . ,backup-dir))
        tramp-auto-save-directory auto-saves-dir))

(setq backup-by-copying t   ; Don't delink hardlinks
      delete-old-versions t ; Clean up the backups
      version-control t     ; Use version numbers on backups
      kept-new-versions 2   ; Keep some new versions of backups
      kept-old-versions 1)  ; Keep some old backups too

(setq backup-directory-alist
      `(("." . ,(concat user-emacs-directory "backups/"))))
#+END_SRC

** Winner-mode: undo/redo window configuration changes
| Command     | Keybinding | Description                               |
|-------------+------------+-------------------------------------------|
| ~winner-undo~ | C-c left   | Undo the most recent window config change |
| ~winner-redo~ | C-c right  | Redo the most recent window config change |

#+BEGIN_SRC emacs-lisp
(winner-mode 1)
#+END_SRC

** display-line-numbers-mode: Displaying line numbers
#+BEGIN_SRC emacs-lisp
(use-package display-line-numbers-mode
  :ensure nil
  :custom
  (display-line-numbers-type 'relative)
  :hook
  (prog-mode . display-line-numbers-mode)
  (markdown-mode . display-line-numbers-mode))
#+END_SRC

* UI
Set up all the fancy user-interface elements to make Emacs look nice.

** Basic Emacs appearance settings
Set the window title to display the current file and major mode.

#+BEGIN_SRC emacs-lisp
(setq-default frame-title-format '("GNU Emacs"))
#+END_SRC 

** Diminish: keeping the modeline uncluttered
#+BEGIN_SRC emacs-lisp
(use-package diminish
  :init
  (diminish 'buffer-face-mode)
  (diminish 'visual-line-mode)
  (diminish 'abbrev))
#+END_SRC 

** Fonts
Set up the fonts for text rendering, pretty self explanatory :)

Here are my current font settings
#+BEGIN_SRC emacs-lisp
(defvar ns/default-font "JetBrainsMono NF"
  "My custom default font choice.")

(defvar ns/fixed-pitch-font "JetBrainsMono NF"
  "My custom fixed pitch font choice.")

(defvar ns/variable-pitch-font "JetBrainsMono NF"
  "My custom variable pitch font choice.")

(custom-set-faces
 `(default ((t (:family ,ns/default-font :slant normal :weight regular :height 110 :width normal :foundry "JB  "))))
 `(fixed-pitch ((t (:family ,ns/fixed-pitch-font :height 110))))
 `(variable-pitch ((t (:family ,ns/variable-pitch-font)))))
#+END_SRC  

Also install helpful icons useful for a ton of packages to add more visual detail. *NOTE* you'll have to run ~M-x all-the-icons-install-fonts~ in order to, well, install the fonts!

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons)
;; (use-package nerd-icons)
#+END_SRC 

** Theme
Give Emacs a nice color scheme! Other themes that I like include:
- doom-palenight
- doom-shades-of-purple
- doom-flatwhite
- doom-tomorrow-day
- mindre-theme

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
  :config
  (load-theme 'doom-one t))

(use-package ef-themes :disabled t
  :config
  (setq ef-themes-headings ; read the manual's entry or the doc string
      '((0 . (variable-pitch light 1.9))
        (1 . (variable-pitch light 1.8))
        (2 . (variable-pitch regular 1.7))
        (3 . (variable-pitch regular 1.6))
        (4 . (variable-pitch regular 1.5))
        (5 . (variable-pitch 1.4)) ; absence of weight means `bold'
        (6 . (variable-pitch 1.3))
        (7 . (variable-pitch 1.2))
        (t . (variable-pitch 1.1))))
  (setq ef-themes-to-toggle '(ef-summer ef-cherie)
        ef-themes-mixed-fonts t
        ef-themes-variable-pitch-ui t))
  
  ;; (ef-themes-select 'ef-summer))

(use-package modus-themes)
  ;; :init
  ;; (setq modus-themes-mode-line '(moody)))
  ;; :config
  ;; (load-theme 'modus-vivendi t))

#+END_SRC

** Modeline
*** doom-modeline
#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :init
  (setq doom-modeline-height 35
        doom-modeline-support-imenu t)
  (doom-modeline-mode 1))
#+END_SRC

** Dashboard
I like having a nice dashboard when Emacs loads in order to remember what I was last working on and (eventually!) view my ~org-agenda~ for the day. Maybe one day I'll revert to just a scratch buffer like others, but I'm sticking with this for now!

#+BEGIN_SRC emacs-lisp

;; Necessary for dashboard in order to get nice seperators between sections
(use-package page-break-lines)

(use-package dashboard
    :custom
    (dashboard-image-banner-max-width 256)
    (dashboard-startup-banner (expand-file-name "emacs.png" user-emacs-directory))
    ;; (dashboard-startup-banner "/Users/nsalesky/Pictures/wallpapers/forest-small.jpg")
    (dashboard-center-content t)
    (dashboard-set-heading-icons t)
    (dashboard-set-file-icons t)
    (dashboard-projects-backend 'project-el)
    ;; (dashboard-projects-switch-function 'projectile-persp-switch-project)
    (dashboard-items '((recents . 5)
                          (projects . 5)
                          (agenda . 5)))
    (initial-buffer-choice (lambda () (get-buffer-create "*dashboard*")))
    ;; :hook (after-init-hook . dashboard-refresh-buffer)
    :config
    (dashboard-setup-startup-hook))

#+END_SRC

** Helpful
Make the Emacs help pages more "helpful".

#+begin_src emacs-lisp
(use-package helpful
  :bind
  (("C-h f" . helpful-callable)
   ("C-h v" . helpful-variable)
   ("C-h k" . helpful-key)))

  ;; :general
  ;; (ns/leader-def
  ;;   "h" '(:ignore t :which-key "help")
  ;;   "hv" '(helpful-variable :which-key "describe variable")
  ;;   "hf" '(helpful-callable :which-key "describe function")
  ;;   "hk" '(helpful-key :which-key "describe key")))
#+end_src

** Hl-todo: Highlight and navigate TODO keywords

#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :config
  (global-hl-todo-mode))
#+END_SRC

** Transparent Frame
Creates a handy little function to toggle a semi-transparent window frame either for aeshetics or to view another window underneath Emacs.

#+BEGIN_SRC emacs-lisp
(defun ns/toggle-window-transparency ()
  "Toggle transparency."
  (interactive)
  (let ((alpha-transparency 90))
    (if (equal alpha-transparency (frame-parameter nil 'alpha-background))
        (set-frame-parameter nil 'alpha-background 100)
      (set-frame-parameter nil 'alpha-background alpha-transparency))))

;; Make the frame transparent when launched
;; (ns/toggle-window-transparency)
#+END_SRC

** Discover.el

#+BEGIN_SRC emacs-lisp
(use-package discover)
#+END_SRC

* Minibuffer
Sets up minibuffer completion with Vertico.

** Vertico
#+BEGIN_SRC emacs-lisp
(use-package vertico
  :init
  (vertico-mode))
#+END_SRC 

** Consult: add helpful functions with completion

#+BEGIN_SRC emacs-lisp
(use-package consult
  :bind
  (;; C-c bindings
   ("C-c h" . consult-history)
   ("C-c m" . consult-mode-command)
   ("C-c k" . consult-kmacro)
   ; M-g bindings
   ("M-g g" . consult-goto-line)
   ("M-g M-g" . consult-goto-line)
   ("M-g i" . consult-imenu)

   ; Buffers
   ("C-x b" . consult-buffer)
   ("C-x 4 b" . consult-buffer-otther-window)
   ("C-x p b" . consult-project-buffer)

   ; Random
   ("C-x r b" . consult-bookmark)
   ("M-y" . consult-yank-pop)

   ; Special search bindings
   ("C-c q" . consult-line)
   ("C-c w" . consult-ripgrep)
   
   ; M-s bindings (search-map)
   ("M-s d" . consult-find)
   ("M-s r" . consult-ripgrep)
   ("M-s l" . consult-line)
   ("M-s L" . consult-line-multi)
   ("M-s k" . consult-keep-lines)
   ("M-s u" . consult-focus-lines)

   ; Isearch integration
   ("M-s e" . consult-isearch-history)
   :map isearch-mode-map
   ("M-e" . consult-isearch-history)
   ("M-s e" . consult-isearch-history)
   ("M-s l" . consult-line)
   ("M-s L" . consult-line-multi)

   ; Minibuffer history
   :map minibuffer-local-map
   ("M-s" . consult-history)
   ("M-r" . consult-history))

  ;; :general
  ;; (ns/leader-def
  ;;   "s" '(:ignore t :which-key "search")
  ;;   "sr" '(consult-ripgrep :which-key "ripgrep")
  ;;   "sl" '(consult-line :which-key "line search")
  ;;   "si" '(consult-imenu :which-key "imenu"))

  :init
  (setq consult-narrow-key (kbd "<"))

  ;; Projectile
  ;; (autoload 'projectile-project-root "projectile")
  ;; (setq consult-project-function (lambda (_) (projectile-project-root)))

  ;; Project.el
  (setq consult-project-function #'consult--default-project-function))
#+END_SRC 

** Orderless: match the different parts of completion candidates

#+BEGIN_SRC emacs-lisp

(use-package orderless
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '(
                                   (file (styles basic partial-completion))
                                   (eglot (styles orderless)))))

#+END_SRC 

** Marginalia: decorate minibuffer completion candidates

#+BEGIN_SRC emacs-lisp
(use-package marginalia
  :bind
  (:map minibuffer-local-map
        ("M-A" . marginalia-cycle))
  :custom
  (marginalia-align 'right)
  :init
  (marginalia-mode)
  :config
  (setq marginalia-command-categories
        (append '((projectile-find-file . project-file)
                  (projectile-find-dir . project-file)
                  (projectile-switch-project . file))
                marginalia-command-categories)))
#+END_SRC

** All-the-icons-completion: add icons to completion candidates

#+BEGIN_SRC emacs-lisp

(use-package all-the-icons-completion
  :after (marginalia all-the-icons)
  :hook (marginalia-mode . all-the-icons-completion-marginalia-setup)
  :init
  (all-the-icons-completion-mode))

#+END_SRC 

** Embark

#+BEGIN_SRC emacs-lisp

(use-package embark
  ;; TODO: set up bindings for embark-act and embark-dwim
  :bind
  (("C-." . embark-act)
   ("M-." . embark-dwim))

  :config

  ;; Hide the mode line for Embark buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))

(use-package embark-consult
  :after (embark consult)
  :demand t
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))

#+END_SRC 

* Editor 
** Rainbow-delimiters: Different color for each parenthesis level
Give parenthases rainbow coloring depending on their nested level in all programming modes.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC 

** YASnippet: Create common snippets
Add various templates to Emacs.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :diminish yas-minor-mode
  :custom
  (yas-verbosity 1)
  :config
  (yas-global-mode))
#+END_SRC

** Which-key: List commands for current prefix
#+begin_src emacs-lisp
(use-package which-key
  :init (which-key-mode)
  :diminish which-key-mode
  :config
  (setq which-key-idle-delay 0.3))
#+end_src

** Iedit: Simple multi-cursor editing

#+BEGIN_SRC emacs-lisp
(use-package iedit
  :bind
  ("C-;" . iedit-mode))
#+END_SRC

** TRAMP: Edit remote files

#+BEGIN_SRC emacs-lisp
(setq tramp-default-method "ssh") ;; Use SSH by default for remote files
#+END_SRC

** expand-region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind
  ("C-=" . er/expand-region))
#+END_SRC

** mwim
#+BEGIN_SRC emacs-lisp
(use-package mwim
  :bind
  ("C-a" . mwim-beginning)
  ("C-e" . mwim-end))
#+END_SRC

* Project Management
Tools to distinguish projects and quickly navigate inside projects and between them.

** Dired
#+BEGIN_SRC emacs-lisp
(use-package dired
  :ensure nil
  :custom
  (dired-kill-when-opening-new-dired-buffer t))
#+END_SRC

** +Projectile+
#+begin_src emacs-lisp :tangle no
(use-package projectile
  :diminish projectile-mode
  :config (projectile-mode)
  ;; :custom ((projectile-completion-system 'ivy))
  :bind-keymap
  ("C-c p" . projectile-command-map)
  :init
  ;(when (file-directory-p "~/Documents")
    ;(setq projectile-project-search-path '("~/Documents")))
  (setq projectile-switch-project-action #'magit-status
        projectile-completion-system 'default))

;; (use-package consult-projectile)

(use-package ripgrep)
#+end_src

** Tab-bar-mode
#+BEGIN_SRC emacs-lisp
(use-package tab-bar
  :ensure nil
  :init
  (tab-bar-mode)
  :custom
  (tab-bar-show nil))
#+END_SRC 

* Version Control
** Magit
#+begin_src emacs-lisp
(use-package magit)
#+end_src

** Forge: issue GitHub pull requests and more

#+BEGIN_SRC emacs-lisp
;; (use-package forge
;;   :after magit)
;; TODO set up personal access token personal to work with pull requests from Emacs  :after magit)
#+END_SRC  

* Org Mode
** Basic config
The very basics for Org-mode, setting up fonts and basic visual features.

#+begin_src emacs-lisp

(use-package org
  :ensure nil
  :bind
  ("C-c l" . org-store-link)
  :hook (org-mode . org-indent-mode)
  :hook (org-mode . variable-pitch-mode)
  :hook (org-mode . visual-line-mode)
  :config
  ;; (add-to-list 'org-tags-exclude-from-inheritance "project")
  ;; (add-to-list 'org-tags-exclude-from-inheritance "rez")
  (org-babel-do-load-languages 'org-babel-load-languages
    '((emacs-lisp . t)
      (python . t)
      (clojure . t)
      (C . t)
      ;; (cpp . t)
      (shell . t)
      (eshell . t)
      (java . t)
      (js . t)
      (plantuml . t)
      (ruby . t)
      (sql . t)))

  :custom
  (org-ellipsis "…")
  (org-pretty-entities t)
  (org-pretty-entities-include-sub-superscripts nil)
  (org-hide-emphasis-markers t)
  (org-hide-leading-stars nil)

  (org-todo-keywords '((sequence "TODO(t)" "WIP(w!)" "HOLD(h!)" "|" "DONE(d!)" "KILL(k!)")))
  (org-use-property-inheritance t)
  (org-log-done 'time)    ; log the time when a task is *DONE*
  (org-log-reschedule 'time)
  (org-log-redeadline 'time)

  (org-directory "~/Documents/notes")
  (org-default-notes-file "~/Documents/notes/notes.org")

  ;; Org-babel
  (org-confirm-babel-evaluate nil)
  (org-plantuml-exec-mode 'jar)
  (org-plantuml-jar-path "~/.local/bin/plantuml.jar")

  (org-latex-pdf-process '("pdflatex -interaction nonstopmode -output-directory %o %f" "bibtex %b" "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f" "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

  (org-src-tab-acts-natively t)
  (org-src-preserve-indentation t))

  ;; :general
  ;; (:keymaps 'org-mode-map :states '(normal emacs visual)
  ;;   "SPC m t" '(org-babel-tangle :which-key "Tangle current file")))
  

#+end_src

** +Org-appear: auto-reveal emphasis markers at point+

#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-appear
  :elpaca (org-appear :type git :host github :repo "awth13/org-appear")
  :hook (org-mode . org-appear-mode))
#+END_SRC 

** Org-agenda and org-capture

*** Basic agenda settings
#+BEGIN_SRC emacs-lisp
(defun ns/org-agenda-reload-files ()
  (interactive)
  (message "Reloading agenda files")
  (setq org-agenda-files (directory-files-recursively "~/Documents/notes/agenda/" "\\.org$")))

(use-package org-agenda
  :ensure nil
  :custom
  (org-agenda-files (directory-files-recursively "~/Documents/notes/agenda/" "\\.org$"))

  (org-agenda-todo-ignore-scheduled 'all)
  (org-agenda-todo-ignore-deadlines 'all)
  (org-agenda-todo-ignore-with-date 'all)
  (org-agenda-tags-todo-honor-ignore-options) 

  (org-agenda-deadline-leaders '("DUE:       " "In %3d d.: " "%2d d. ago: "))
  (org-agenda-scheduled-leaders '("DO:       " "Sched. %2dx: "))

  (org-agenda-sticky t)
  (org-agenda-dim-blocked-tasks nil)
  (org-agenda-time-grid (quote
                         ((daily today remove-match)
                          (800 1200 1600 2000)
                          "......" "----------------")))
  ;; (org-agenda-hide-tags-regexp ".")     ; hide all tags in the agenda

  :bind
  ;; ("C-c c" . org-capture)
  ("C-c a" . org-agenda)
  ("C-c r" . ns/org-agenda-reload-files))
  
#+END_SRC  
 
** Org-present

#+BEGIN_SRC emacs-lisp
(defun ns/org-present-begin ()
  (setq-local ns/olivetti-mode-enabled (bound-and-true-p olivetti-mode)) ;; remember if olivetti was already enabled or not
  (olivetti-mode 1)                                                      ;; enable olivetti-mode regardless

  ;; Tweak the font sizes
  (setq-local face-remapping-alist '((default (:height 1.5) variable-pitch)
                                     (header-line (:height 4.0) variable-pitch)
                                     (org-document-title (:height 1.75) org-document-title)
                                     (org-code (:height 1.55) org-code)
                                     (org-verbatim (:height 1.55) org-verbatim)
                                     (org-block (:height 1.25) org-block)
                                     (org-block-begin-line (:height 0.7) org-block)))

  ;; Set a blank header line string to create some blank space at the top
  (setq-local header-line-format " ")

  (message "Starting presentation. Good luck!"))

(defun ns/org-present-end ()
  (unless (symbol-value 'ns/olivetti-mode-enabled)
    (olivetti-mode 0))                                                   ;; disable olivetti-mode only if it wasn't open before the presentation

  ;; Reset the font customizations
  (setq-local face-remapping-alist '((default variable-pitch default)))

  ;; Reset the header line back to nothing
  (setq-local header-line-format nil)

  (message "Ending presentation. Nice job!"))

(use-package org-present
  :config
  (add-hook 'org-present-mode-hook 'ns/org-present-begin)
  (add-hook 'org-present-mode-quit-hook 'ns/org-present-end))

#+END_SRC 

** org-superstar: change the headline symbols

#+BEGIN_SRC emacs-lisp
(use-package org-superstar
  :custom
  (org-superstar-headline-bullets-list '("⟶"))
  (org-superstar-leading-bullet ?\s)
  :hook
  (org-mode . org-superstar-mode))
#+END_SRC

** +Org-modern+
Give Org-mode documents some extra visual polish.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-modern
  :config
  (global-org-modern-mode))
#+END_SRC

* Note Taking
** +Org-roam+

#+BEGIN_SRC emacs-lisp :tangle no
(use-package emacsql-sqlite-builtin)

(use-package org-roam
  :diminish
  :bind
  (:prefix-map ns/notes-prefix-map
               :prefix "C-c n"
               ("l" . org-roam-buffer-toggle)
               ("f" . org-roam-node-find)
               ("g" . org-roam-graph)
               ("i" . org-roam-node-insert)
               ("c" . org-roam-capture)
               ;; Dailies
               ("d" . org-roam-dailies-goto-today)
               ("j" . org-roam-dailies-capture-today))
  :custom
  (org-roam-directory (file-truename "~/Documents/notes/"))
  (org-roam-file-extensions '("org" "md"))
  (org-roam-dailies-directory "logs")
  (org-roam-database-connector 'sqlite-builtin)
  (org-roam-capture-templates
   '(("d" "default" plain (file "~/Documents/notes/capture-templates/default.org")
      :target (file "${slug}.org")
      :unnarrowed t)
     ("r" "Rez" plain (file "~/Documents/notes/capture-templates/rez.org")
      :target (file "${slug}.org")
      :unnarrowed t)
     ("p" "Project" plain (file "~/Documents/notes/capture-templates/project.org")
      :target (file "${slug}.org")
      :unnarrowed t)
     ("7" "Weekly" plain (file "~/Documents/notes/capture-templates/weekly.org")
      :target (file "logs/${slug}.org")
      :unnarrowed t)))
  (org-roam-dailies-capture-templates
      '(("d" "default" plain
         (file "~/Documents/notes/capture-templates/daily.org")
         :target (file "%<%Y-%m-%d>.org"))))
  :init
  (setq org-roam-v2-ack t)
  :config
  (setq org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
  (org-roam-db-autosync-enable))
#+END_SRC

** +consult-org-roam+
#+BEGIN_SRC emacs-lisp :tangle no
(use-package consult-org-roam
  :diminish
  :after org-roam
  :init
  (require 'consult-org-roam)
  (consult-org-roam-mode 1)
  :custom
  (consult-org-roam-grep-func #'consult-ripgrep)
  (consult-org-roam-buffer-narrow-key ?r)
  (consult-org-roam-buffer-after-buffers nil)
  :config
  ;; Eventually suppress previewing for certain functions
  (consult-customize
   consult-org-roam-forward-links
   :preview-key (kbd "M-."))
  :bind
  ;; Define some convenient keybindings as an addition
  ("C-c n f" . consult-org-roam-file-find)
  ("C-c n b" . consult-org-roam-backlinks)
  ("C-c n l" . consult-org-roam-forward-links)
  ("C-c n s" . consult-org-roam-search))
#+END_SRC

** +Org-roam-ui+
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-roam-ui
    (:host github :repo "org-roam/org-roam-ui" :branch "main" :files ("*.el" "out"))
    :after org-roam
;;  :hook (after-init . org-roam-ui-mode)
    :custom
    (org-roam-ui-sync-theme t)
    (org-roam-ui-follow t)
    (org-roam-ui-update-on-save t)
    (org-roam-ui-open-on-start t))
#+END_SRC

* Shells/Terminal Emulators
** with-editor-async-shell-command
#+BEGIN_SRC emacs-lisp
(keymap-global-set "M-&" 'with-editor-async-shell-command)
#+END_SRC

** Vterm
#+BEGIN_SRC emacs-lisp
  (use-package vterm
    :custom
    (vterm-shell "fish")
    (vterm-max-scrollback 10000))

  (use-package multi-vterm
    :bind
    (:prefix-map ns/multi-vterm-prefix-map
                 :prefix "C-c v"
                 ("v" . multi-vterm)
                 ("C-p" . multi-vterm-prev)
                 ("p" . multi-vterm-prev)
                 ("C-n" . multi-vterm-next)
                 ("n" . multi-vterm-next)
                 ("t" . multi-vterm-dedicated-toggle)
                 ("p" . multi-vterm-project)
                 ("r" . multi-vterm-rename-buffer)))
    ;; :general
    ;; (ns/leader-def
    ;;   "v" '(:ignore t :which-key "terminal")
    ;;   "vv" '(multi-vterm :which-key "open new term")
    ;;   "vp" '(multi-vterm-prev :which-key "prev term")
    ;;   "vn" '(multi-vterm-next :which-key "next term")
    ;;   "vr" '(multi-vterm-rename-buffer :which-key "rename term")))
#+END_SRC 

* Programming
** General Tools
*** Treesitter

#+BEGIN_SRC emacs-lisp
(setq treesit-language-source-alist
   '((bash "https://github.com/tree-sitter/tree-sitter-bash")
     (cmake "https://github.com/uyha/tree-sitter-cmake")
     (css "https://github.com/tree-sitter/tree-sitter-css")
     (dockerfile "https://github.com/camdencheek/tree-sitter-dockerfile")
     (elisp "https://github.com/Wilfred/tree-sitter-elisp")
     (go "https://github.com/tree-sitter/tree-sitter-go")
     (gomod "https://github.com/camdencheek/tree-sitter-go-mod")
     (html "https://github.com/tree-sitter/tree-sitter-html")
     (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
     (json "https://github.com/tree-sitter/tree-sitter-json")
     (make "https://github.com/alemuller/tree-sitter-make")
     (markdown "https://github.com/ikatyang/tree-sitter-markdown")
     (python "https://github.com/tree-sitter/tree-sitter-python")
     (rust "https://github.com/tree-sitter/tree-sitter-rust")
     (toml "https://github.com/tree-sitter/tree-sitter-toml")
     (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
     (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
     (typst "https://github.com/uben0/tree-sitter-typst")
     (yaml "https://github.com/ikatyang/tree-sitter-yaml")))

(customize-set-variable 'treesit-font-lock-level 4)
#+END_SRC

*** Eglot: Language-server protocols
#+BEGIN_SRC emacs-lisp
(use-package jsonrpc)

(use-package eglot
  :bind
  (:prefix-map ns/eglot-actions-map
               :prefix "C-c e"
               ("a" . eglot-code-actions)
               ("f" . eglot-format-buffer))
  :custom
  (eglot-events-buffer-size 0) ; Disable the events buffer for performance
  (eglot-send-changes-idle-time 0.5)
  :hook
  (eglot-managed-mode . eglot-inlay-hints-mode)
  :config
  (add-to-list 'eglot-server-programs
               '(python-ts-mode . ("basedpyright-langserver")))
  ;; (add-to-list 'eglot-server-programs
               ;; `(rustic-mode . ("/home/nsalesky/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rust-analyzer"
                                ;; :initializationOptions
                                ;; (:procMacro (:attributes (:enable t)
                                ;;                          :enable t)
                                ;;  :cargo (:buildScripts (:enable t))
                                ;;  :diagnostics (:disabled ["unresolved-proc-macro"
                                ;;                           "unresolved-macro-call"])))))
  (add-to-list 'eglot-server-programs
               '(svelte-mode . ("svelteserver" "--stdio"))))
#+END_SRC 

*** Corfu: Completion at point
Configure the ~corfu~ completion-at-point package. This configuration was inspired by the official documentation and [[https://kristofferbalintona.me/posts/202202270056/][here]].

#+BEGIN_SRC emacs-lisp
(use-package corfu
  ;; :elpaca (corfu :files (:defaults "extensions/*")
  ;;                  :includes (corfu-info corfu-history))
  :bind
  (:map corfu-map
        ("C-n" . corfu-next)
        ("C-p" . corfu-previous)
        ("<tab>" . corfu-next)
        ("S-<tab>" . corfu-previous)
        ("<escape>" . corfu-quit)
        ("C-g" . corfu-quit)
        ("<return>" . corfu-insert)
        ("M-d" . corfu-show-documentation)
        ("M-l" . corfu-show-location))

  :custom
  (corfu-auto t)
  (corfu-auto-prefix 3) ; Minimum length of prefix for auto-complete
  (corfu-auto-delay 0) ; Immediately start auto-completion

  (corfu-popupinfo-delay 0)

  (corfu-min-width 80) ; Min width of popup, I like to have it consistent
  (corfu-max-width corfu-min-width) ; Always have the same width
  (corfu-count 14) ; Max number of candidates to show
  (corfu-scroll-margin 4)
  ;; (corfu-cycle nil)

  ;; (corfu-quit-at-boundary nil)
  ;; (corfu-seperator ?\s)            ; Use space
  ;; (corfu-quit-no-match 'seperator) ; Don't quit if there is 'corfu-seperator' inserted
  ;; (corfu-quit-no-match t)
  (corfu-preview-current 'insert)  ; Preview first candidate
  (corfu-preselect-first t)        ; Preselect first candidate?

  ;; Enable indentation+completion using the TAB key instead of M-TAB
  (tab-always-indent 'complete)
  ;; (completion-cycle-threshold nil)

  (corfu-excluded-modes '(eshell-mode))

  :init
  (global-corfu-mode)
  (corfu-popupinfo-mode))

;; Example 4: Define a defensive Dabbrev Capf, which accepts all inputs.  If you
;; use Corfu and `corfu-auto=t', the first candidate won't be auto selected even
;; if `corfu-preselect=first'. You can use this instead of `cape-dabbrev'.
(defun my-cape-dabbrev-accept-all ()
  (cape-wrap-accept-all #'cape-dabbrev))

(use-package cape
  :init
  (add-to-list 'completion-at-point-functions #'my-cape-dabbrev-accept-all))
  

(use-package kind-icon :disabled t
  :custom
  (kind-icon-default-face 'corfu-default)
  :config
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+END_SRC 

*** DAPE: Debug Adapter Protocol
I've been eagerly awaiting a package just like this for a long time now, so I'm very excited to try it out.
It'll be nice having a good debug experience with the simplicity of eglot.

#+BEGIN_SRC emacs-lisp :tangle nil
(use-package dape
  :hook
  ;; Save breakpoints on quit
  (kill-emacs . dape-breakpoint-save)
  ;; Load breakpoints on startup
  (after-init . dape-breakpoint-load)

  :config
  ;; Save buffers on startup, useful for interpreted languages
  (add-hook 'dape-on-start-hooks (lambda () (save-some-buffers t t))))

  ;; custom debug adapter configs
  ;; (add-to-list 'dape-configs
  ;;              (lldb-vscode modes
  ;;             (c-mode c-ts-mode c++-mode c++-ts-mode rust-mode rust-ts-mode)
  ;;             ensure dape-ensure-command command-cwd dape-command-cwd command "lldb-vscode" :type "lldb-vscode" :cwd "." :program "a.out")
  
#+END_SRC

*** Format All The Code: Simple code formatting
A simple code formatting system for a ton of languages.

#+begin_src emacs-lisp

(use-package format-all)
  ;:hook
  ;(prog-mode . format-all-mode)

#+end_src

*** Flymake
#+BEGIN_SRC emacs-lisp
(use-package flymake
  :bind
  (:map flymake-mode-map
        ("M-p" . flymake-goto-prev-error)
        ("M-n" . flymake-goto-next-error)))
#+END_SRC 

*** +Breadcrumb: header line for project structure+
#+BEGIN_SRC emacs-lisp :tangle no
(use-package breadcrumb
  :elpaca (:type git :host github :repo "joaotavora/breadcrumb")
  :hook (prog-mode . breadcrumb-local-mode))
#+END_SRC

*** Verb
#+BEGIN_SRC emacs-lisp
(use-package verb
  :after (org)
  :config
  (define-key org-mode-map (kbd "C-c C-r") verb-command-map))
#+END_SRC

*** ws-butler
#+BEGIN_SRC emacs-lisp
(use-package ws-butler
  :diminish ws-butler-mode
  :hook
  (prog-mode . ws-butler-mode))
#+END_SRC

*** imenu-list
#+BEGIN_SRC emacs-lisp
(use-package imenu-list)
#+END_SRCp

*** RE-Builder
A pretty useful tool for debugging regular expressions. I use the ~string~ mode so that I don't have to backslash the backslashes.

#+BEGIN_SRC emacs-lisp
(use-package re-builder
  :ensure nil
  :custom
  (reb-re-syntax 'string))
#+END_SRC 

** Languages
*** YAML
#+BEGIN_SRC emacs-lisp

(use-package yaml-mode
  :mode "\\.yml\\'")

#+END_SRC 

*** C/C++
#+begin_src emacs-lisp

;; (add-hook 'c-mode-hook 'lsp)
;; (add-hook 'c++-mode-hook 'lsp)
(add-hook 'c-mode-hook 'eglot-ensure)
(add-hook 'c++-mode-hook 'eglot-ensure)

#+end_src

*** Clojure

#+BEGIN_SRC emacs-lisp
(defun ns/setup-cider-format-hook
    ()
  (add-hook 'before-save-hook 'cider-format-buffer nil t))

(use-package clojure-mode
  :mode "\\.clj\\'")

(use-package cider
  :hook
  (clojure-mode . ns/setup-cider-format-hook)
  (clojurescript-mode . ns/setup-cider-format-hook)
  (clojurec-mode . ns/setup-cider-format-hook))
#+END_SRC 

*** Common Lisp

#+BEGIN_SRC emacs-lisp
(use-package sly
  :custom
  (inferior-lisp-program "sbcl"))
#+END_SRC

*** +GLSL: OpenGL shaders+
#+BEGIN_SRC emacs-lisp :tangle no
(use-package glsl-mode
  :mode ("\\.glsl\\'" "\\.vert\\'" "\\.frag\\'" "\\.geom\\'"))
#+END_SRC

*** Go
#+BEGIN_SRC emacs-lisp
(use-package go-ts-mode
  :ensure nil
  :mode "\\.go\\'"
  :hook (go-ts-mode . eglot-ensure)
  :custom
  (go-ts-mode-indent-offset 4))
#+END_SRC 

*** Janet
#+BEGIN_SRC emacs-lisp :tangle nil
;; (use-package janet-ts-mode
;;   :vc (:url "https://github.com/sogaiu/janet-ts-mode.git"
;;        :branch "master"))

(use-package janet-mode)

;; (autoload 'inf-janet "inf-janet" "Run an inferior Janet process" t)
;; (add-hook 'janet-mode-hook 'inf-janet-minor-mode)

#+END_SRC

*** LaTeX
Recompile LaTeX documents automatically when saved. 

#+BEGIN_SRC emacs-lisp
(defun ns/compile-tex-doc ()
  "Asynchronously compile the current tex buffer to a pdf."
  (start-process "pdflatex" nil "pdflatex" (buffer-file-name)))
  ;; (async-shell-command (concat "pdflatex " (buffer-file-name))))

(use-package tex-mode
  :ensure nil
  :hook (latex-mode . (lambda () (add-hook 'after-save-hook #'ns/compile-tex-doc nil t))))
#+END_SRC

*** Markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :mode "\\.md\\'")
#+END_SRC 

*** Nix
#+BEGIN_SRC emacs-lisp
(use-package nix-mode
  :mode "\\.nix\\'")
#+END_SRC

*** OCaml

#+BEGIN_SRC emacs-lisp
(defun opam-env ()
  (interactive nil)
  (dolist (var (car (read-from-string (shell-command-to-string "opam config env --sexp"))))
    (setenv (car var) (cadr var))))

(use-package tuareg
  :mode (("\\.ocamlinit\\'" . tuareg-mode)))

(use-package dune)

(use-package merlin
  :hook
  (tuareg-mode . merlin-mode)
  :custom
  (merlin-error-after-save nil))

(use-package merlin-eldoc
  :hook (tuareg-mode . merlin-eldoc-setup))

(use-package utop
  :hook
  (tuareg-mode . utop-minor-mode))
#+END_SRC

*** PlantUML

#+BEGIN_SRC emacs-lisp
(use-package plantuml-mode
  :mode "\\.plantuml\\'"
  :custom
  (plantuml-jar-path "~/.local/bin/plantuml.jar")
  (plantuml-default-exec-mode 'jar)
  :config
  (add-to-list
   'org-src-lang-modes
   '("plantuml" . plantuml)))
#+END_SRC

*** Python
#+BEGIN_SRC emacs-lisp
(use-package python-mode
  :hook (python-mode . eglot-ensure)
  ;; :hook (python-mode . (lambda ()
                         ;; (eglot-ensure)
                         ;; (setq tab-width 4)))
  :custom
  (python-shell-interpreter "python3")
  :config
  (setq python-ts-mode-hook python-mode-hook))
#+END_SRC

*** Racket
#+BEGIN_SRC emacs-lisp
(defun ns/setup-racket-mode ()
  (add-to-list 'completion-at-point-functions
               #'racket-complete-at-point))

(use-package racket-mode
  :mode "\\.rkt\\'"
  :hook
  (racket-mode . ns/setup-racket-mode))
            
#+END_SRC

#+RESULTS:

*** Svelte
#+BEGIN_SRC emacs-lisp
(define-derived-mode svelte-mode
  web-mode "Svelte"
  "Major mode for Svelte.")

(use-package svelte-mode :ensure nil
  :hook (svelte-mode . eglot-ensure)
  :mode "\\.svelte\\'")
#+END_SRC

*** Typescript

#+begin_src emacs-lisp
(use-package typescript-mode
  :mode ("\\.ts\\'" "\\.tsx\\'" "\\.js\\'" "\\.jsx\\'")
  :hook (typescript-mode . eglot-ensure)
  :config
  (setq typescript-indent-level 4))
#+end_src

*** Ruby

#+BEGIN_SRC emacs-lisp
(use-package ruby-mode
  :ensure nil)

(use-package inf-ruby) ;; Interact with a Ruby REPL

(use-package robe
  :hook (ruby-mode . robe-mode)
  :hook (ruby-ts-mode . robe-mode))
#+END_SRC

*** Rust
Inspired by https://robert.kra.hn/posts/2021-02-07_rust-with-emacs/
Eglot ~rust-analyzer~ configuration provided by https://gist.github.com/casouri/0ad2c6e58965f6fd2498a91fc9c66501

Most Rustic keybindings begin with =C-c C-c=

#+begin_src emacs-lisp

;; (defun ns/setup-eglot-rust ()
;;   (setq-local eglot-workspace-configuration
;;               '(:rust-analyzer
;;                 (:procMacro (:attributes (:enable t)
;;                                          :enable t)
;;                             :cargo (:buildScripts (:enable t))
;;                             :diagnostics (:disabled ["unresolved-proc-macro"
;;                                                      "unresolved-macro-call"])))))

;; (defclass eglot-rust-analyzer (eglot-lsp-server) ()
;;   :documentation "A custom class for rust-analyzer.")

;; (cl-defmethod eglot-initialization-options ((server eglot-rust-analyzer))
;;   eglot-workspace-configuration)

(use-package rustic
  :custom
  (rustic-lsp-client 'eglot)
  (rustic-format-on-save t)
  :hook
  (rustic-mode . (lambda () (flycheck-mode -1)))
  (rustic-mode . eglot-ensure))
#+end_src

*** Web
Editing in a mixed-language web format.

#+BEGIN_SRC emacs-lisp
;; (defun ns/toggle-web-mode ()
;;   "Toggles web-mode on or off, switching back to the previous major mode when disabled."
;;   (interactive)
;;   (if (eq 'web-mode major-mode)
;;       (funcall (symbol-value 'ns/prev-major-mode))
;;     (progn
;;       ;; (setq-local ns/prev-major-mode major-mode)
;;       (set (make-local-variable 'ns/prev-major-mode) major-mode)
;;       (web-mode))))

(use-package web-mode
    :commands (web-mode)
    :mode (("\\.html" . web-mode)
            ("\\.htm" . web-mode)
            ;; ("\\.tsx\\'" . web-mode)
            ;; ("\\.jsx\\'" . web-mode)
            ("\\.mustache\\'" . web-mode)
            ("\\.phtml\\'" . web-mode)
            ("\\.as[cp]x\\'" . web-mode)
            ("\\.erb\\'" . web-mode)
            ("\\.sgml\\'" . web-mode)
            ("\\.svelte\\'" . web-mode)))
    ;; :bind
    ;; ("C-c h" . ns/toggle-web-mode))
#+END_SRC 

* Utilities
** Open file as superuser

#+BEGIN_SRC emacs-lisp
(defun ns/sudo-find-file (filename)
  (interactive "F")
  (find-file (concat "/sudo::"
                     (expand-file-name filename))))
#+END_SRC

* Documents
** PDFs

#+BEGIN_SRC emacs-lisp
(use-package tablist)

(use-package pdf-tools
  :config
  (pdf-loader-install))
#+END_SRC

Extends ~saveplace-mode~ with support for PDFs using ~pdf-tools~
#+BEGIN_SRC emacs-lisp
(use-package saveplace-pdf-view)
#+END_SRC
 
